# 应用缓冲区来处理、编码和解码二进制数据

**本章提要：**

* 理解Node中为何需要缓冲区

* 用字符串创建缓冲区

* 将缓冲区转换成字符串

* 在缓冲区中处理数据

* 切分和复制缓冲区

JavaScript 善于处理字符串，但由于它最初是被设计用来处理 HTML文档的， 因此它并不善于处理二进制数据。JavaScript 中没有字节类型，也没有结构化类型，当然也没有字节数组类型，只有数值类型和字符串类型。

由于 Node 是基千 JavaScript 开发的，所以它可以处理类似 HTTP 这样的文本协议，但是也可以用它来与数据库通信、操作图像以及上传文件。可以想象，如果只是用字符串完成上述任务将会相当困难。在早期，Node 通过将每个字节编码为文本字符来处理二进制数据， 但现在已经证明该方法既浪费资源，速度又缓慢，还不可靠，并且难以控制。

为了使这类二进制数据处理任务变得容易些，Node 引入了一个二进制缓冲区实现，该实现以 **Buffer 伪类**中的 JavaScript API 形式暴露给外界。缓冲区的长度_以**字节**为计量单位_，并且可以随机地设置和获取缓冲区中的数据。

> **\[info\]** 「注意：」
>
> Buffer 类的另一个特别之处是数据占用的内存并不是分配在 JavaScript VM 内存堆中，也就是说这些对象不会被垃圾收集算法处理：它会占据一个不会被修改的永久内存地址，这避免了因缓冲区内容的内存复制所造成的 CPU 浪费．

## 创建缓冲区

可以使用 UTF-8 编码格式的字符串来创建缓冲区， 示例代码如下所示：

```js
var buf = new Buffer('Hello World!');
```

也可以用其他编码格式的字符串创建缓冲区，只要指定编码格式作为构造函数的第二个参数：

```js
var buf = new Buffer('8b76fde713ce', 'base64');
```

可以被接受的编码格式以及它们的标识符如下所示：

* **ascii** — ASCII。该编码格式仅适用于 ASCII 字符集。

* **utf8** — UTF-8。这是一 种变宽度的编码格式， 可以 表 示 Unicode 字符集中的任意字符，它是网络上的首选编码格式。在你没有指定编码格式参数的情况下，utf8 是默认的编码格式。

* **base64 **— Base64 。这种编码格式基于64个可打印的 ASCII 字符来表示二进制数据， Base64 通常用于在字符文档内嵌入可以被转换成字符串的二进制数据，在需要时又可以完整无损地转换回原来的二进制格式。

如果缓冲区没有用具体内容初始化，则可以通过指定容量大小来创建缓冲区， 以备将来容纳数据。可以通过指定长度创建新的缓冲区， 如下所示：

```js
var buf = new Buffer(l024); // 创建长度为1024字节的缓冲区
```

## 在缓冲区中获取和设置数据

在创建或者获取缓冲区之后， 你也许想查看或者修改其内容， 那么可以使用 `[]` 操作符来访问缓冲区中的某个字节，如同访问数组一般， 如下所示：

```js
var buf = new Buffer('my buffer content') ;
// 访问buf缓冲区的第10个字节
console.log(buf(10)); // -> 99。这里输出的输出的是 Unicode 字符编码
```

> **\[info\]** 注意：
>
> 当创建一个已被初始化的缓冲区时，请记住该缓冲区中包含的数据，并非是 0，而是一些随机值。
>
> ```js
> var buf = new Buffer(1024) ;
>
> console.log(buf[100]); //-> 5 (某个随机值）
> ```

同样， 也可以处理任意位置上的数据：

```js
buf[99] = 125; // 将第100个位置上的数据设置为125
```

> **\[info\]** 注意:
>
> 在某些情况下， 一些缓冲区操作并不会产生错误， 例如：
>
> * 如果将缓冲区中的某个位置设置为一个大于 255 的数，那么将会用 256 对该数取模， 最终将取模结果赋给该位置。
>
> * 如果将缓冲区中某个位置设置为 256，那么该位置实际上是被赋值为0
>
> * 如果将缓冲区中某个位置设置成 100.7 这样的小数，那么该位置仅会存储整数部分，本例中存储的是100。
>
> * 如果尝试给超出缓冲区边界的位置赋值，那么赋值操作将以失败告终，缓冲区也不会发生变化。

还可以通过查询缓冲区的 `length` 属性来获取其长度， 如下所示：

```js
var buf = new Buffer(100);
console.log(buf.length); // -> 100
```

然后可以使用缓冲区长度迭代缓冲区内容，来设置或者获取每个字节：

```js
var buf = new Buffer(100);
for (var i = 0; i < buf.length; i++) {
    buf[i] = i;
}
```

在上面的代码中新建一个大小为 100 字节的缓冲区， 并从 0 ~ 99 依次设置缓冲区中每一个字节。

## 切分缓冲区

—旦创建或获取一个缓冲区， 也许需要将此缓冲区的一部分提取出来。可以通过指定始位置和结束位置来切分缓冲区， 从而创建一个更小的缓冲区， 如下所示：

```js
var buffer = new Buffer("This is the content of my buffer");
var smallerBuffer = buffer.slice(8, 19);
console.log(smallerBuffer.toString()); // -> the content"
```

注意，在切分缓冲区时并没有分配新的内存，也没有进行任何复制，新缓冲区还是使用父缓冲区的内存区域，只不过引用了父缓冲区不同的起始位置和/或结束位置。这一点蕴含以下几方面的意思。  


首先，如果程序修改了父缓冲区， 并且修改只要影响到子缓冲区范围内的数据，那么子缓冲区也会修改。因为父缓冲区和子缓缓冲区是不同的 JavaScript 对象，所以很容易忽略这个问题，导致一些错误。

其次，在用这种方法从父缓冲区创建一个较小的子缓冲区时，父缓冲区在操作结束后依然继续被保留，并不会被垃圾回收器回收，如果不谨慎处理的话，很容易造成内存泄露。

> **\[info\]** 注意：
>
> 如果担心因保留父缓冲区而产生内存泄露问是，可以使用 copy 方法来替代 slice 方法，下一节会介绍 copy 方法。

## 复制缓冲区

还可以应用 copy 方法，将缓冲区的一部分复制到另一个缓冲区中，如下所示：

```js
var bufferl = new Buffer("this is the content of my buffer");
var buffer2 = new Buffer(ll);
var targetStart = 0;
var sourceStart = 8;
var sourceEnd = 19;
bufferl.copy(buffer2, targetStart, sourceStart, sourceEnd);
console.log(buffer2.toString()) // -> "the content"

```

在上面的代码中，将源缓冲区的第8到第19个位置上的数据复制到目标缓冲区的起始位置。

## 缓冲区解码

缓冲区可以转换成一个 UTF-8 编码格式的字符串，如下所示：

```js
var str = buf.toString();
```

也可以将缓冲区转换成其他指定编码格式的字符串，例如，如果要将一个缓冲区转换成 base64 编码格式的字符串，可以这样做：

```js
var b64Str = buf.toString("base64");
```

还可以使用 `toString` 方法，将 UTF-8 编码格式的字符串转换成 base64 编码格式的字符串，如下所示：

```js
var utf8String = 'my string';
var buf = new Buffer(utf8String); // 将缓冲区作为桥梁
var base64String = buf.toString('base64');
```

## 本章小结

有时你不得不对二进制数据进行处理， 但是“ 原生态” 的 JavaScript 并没有为处理该任务提供明确的方式。

Node 中的 Buffer 类对访问连续内存块的操作进行了封装，可以处理内存中的数据以及切分缓冲区，还可以在两个缓冲区之间进行内存复制。

此外，还可以将缓冲区转换成某种编码格式的字符串，或者反过来将字符串转换成缓冲区， 以便访问或处理每个字节。



