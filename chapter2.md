# Node 简介

**本章提要：**

* 什么是事件驱动编程风格？使用这种风格有什么优点？

* Node.js 和 JavaScript 如何简化了事件驱动编程？

在传统编程中，I/O 操作和本地函数调用的处理方式相同： 处理过程需要一直等待直到某个操作结束才能继续下去。这种进行 I/O 操作的阻塞式编程模型继承自早期的分时系统，在这类系统中，每一个进程都对应着一个用户，这样做的目的是使用户之间相互隔离。并且在这类系统中， 用户在决定下一步操作之前， 通常都必须先结束一个操作。但是随着计算机网络和 Internet 的广泛应用，这种“ 单用户、单进程” 的模型不具备较好的伸缩性，管理众多进程在内存和上下文交换代价方面给操作系统带来了沉重的负担， 当任务的数量达到一定值后， 其性能就开始急剧下降。

在除了上述编程模型之外，多线程编程模型是另一个选择。线程可以看做是一种轻量级进程，它与同一进程内的其他线程共享内存。线程作为早期模型的扩展而被创建， 以适应若干并发线程的执行。当一个线程等待 I/O 操作时， 另一个线程就可以接管CPU, 等待线程将在 I/O 操作结束时被唤醒， 这意味着线程在其执行期间可以被中断，之后又能够恢复执行，并且有些系统允许线程在不同的CPU核上并行运行。

在这意味着程序员并不知道在给定时刻究竟是哪些线程在执行，所以他们必须仔细处理对共享内存状态的并发访问， 使用诸如线程锁和信号量这样的同步原语协调对某些数据结构的访问， 强制它们对线程执行调度的各种途径进行预测以避免问题的发生。假如应用程序非常依赖于线程间的共享状态， 那么这种编程方式容易导致随机发生的危险错误， 并且这些错误很难查找。

如果不让操作系统进行线程调度，那么程序员的另一个选择是协同多线程， 在这种模式下，程序员负责显式地让 CPU 为其他线程的执行分配时间，因为是人为负责线程调度，所以可以放宽同步需求，但是基于和普通多线程同样的原因，这种方法也很复杂并且容易出错。

## 事件驱动编程风格介绍

事件驱动编程是指程序的执行流程取决于事件的编程风格，事件由事件处理程序或者事件回调函数进行处理。当某些重要的事件发生时——例如数据库查询结果可用或者用户单击了某个按钮，就会调用事件回调函数。

以下面的代码为例，看看在典型的阻塞式 I/O 编程中，如何实现对数据库的查询：

```js
result = query('SELECT * FROM posts WHERE id= 1');
do_something_with (result);
```

上述查询过程需要当前线程或者进程一直等待，直到数据库层完成对查询的处理为止。

而在事件驱动系统中， 上述查询则以如下方式进行：

```js
query_finished = function (result) {
    do_something_with(result);
};

query ('SELECT * FROM posts WHERE id = 1', query_finished);
```

此处首先定义了在查询完成之后将会发生的处理过程，并且将这个过程存储在一个名为 `query_finished` 的函数当中，然后将函数名作为查询的一个参数。这样，当查询完成之后将会调用 `query_finished` 函数，而不仅仅只是返回查询结果。

这种以定义当感兴趣事件发生时由系统调用的函数来取代应用返回值的编程风格被称为**事件驱动编程**或者**异步编程**，它是 Node 的显著特征之一。这种编程风格意味着当前进程在处理 I/O 操作时不会发生阻塞，因此，多个 I/O 操作可以并行进行，当每个操作结束时，将会分别调用其对应的回调函数。

事件驱动编程风格和事件循环相伴相生，_事件循环是一个处于不间断循环中的结构_，该结构主要具有两项功能一一**事件检测**和**事件触发处理**，在每一轮循环中，它都必须检测发生了什么事件。当事件发生时，事件循环还要决定调用哪个回调函数。

事件循环只是在一个_进程_ 中运行的_单个线程_，这意味着当事件发生时，可以不用中断就运行事件处理程序，这样做有以下两个特点：

* 在任一给定时刻，最多运行一个事件处理程序。

* 事件处理程序可以不间断地运行直到结束。

这使得程序员能放宽同步要求，并且不必担心执行并发线程会改变共享内存的状态。

> 「众所周知的秘密」
>
> 在相当一段时间内， 系统编程领域已经知道事件驱动编程是创建处理众多并发连接的服务的最佳方法。由于不用保存很多上下文， 因此节省了大量内存；又因为也没有那么多上下文切换， 又节省了大量执行时间。
>
> 这种理念已经渗透进其他平台和领域， 例如 Ruby 的 _Event Machine_、Perl 的 _AnyEvent_ 和 Python 的 _Twisted_ 都是一些知名的事件循环实现，当然还包括其他一些语言。
>
> 使用上述框架之一实现应用程序时需要该框架指定的编程语言和库， 例如使用 Event Machine 时，应该避免使用同步库，为了利用非阻塞模式的优势，你被限制使用专门为 Event Machine 构建的异步库。如果使用了阻塞库（例如Ruby的大多数标准库）， 那么所搭建的服务器无法进行理想的伸缩， 因为事件循环经常会被阻塞， 从而妨碍处理 I/O 事件。从诞生的第一天开始，Node就是作为一个非阻塞 I/O 服务器平台而设计的， 所以基于它构建的所有应用程序都会是非阻塞的。因为JavaScript非常小， 并且没有为 I/O 操作增加额外的东西\(JavaScript没有标准 I/O 库）， 所以Node的构建基础非常纯净。

## Node 和JavaScript 如何简化异步应用程序的编写

Node 的作者 RyanDahl 是从构建一个 C 语言平台开始他的项目的，但是这样一来，维护函数调用之间的上下文就十分复杂， 导致编写的代码晦涩难懂。然后他转向了 Lua，但是 Lua 已经有了一些阻塞式 I/O 库，将阻塞式和非阻塞式混合起来，会让开发者产生混淆，使他们难以构建伸缩性良好的应用程序， 因此 Lua 也不是一个理想的选择。

Dahl 最后转向了JavaScript，JavaScript 具有闭包和第一类函数， 这使得它非常适合于事件驱动编程，JavaScript 的影响力是 Node如此流行的主要原因之一。

### 什么是闭包

闭包就是函数， 但是它可以继承并访问它自身被声明的那个作用域（静态作用域）里的变量。当你将一个回调函数作为参数传递给另外一个进行 I/O 操作的函数时， 回调函数稍后会被调用，神奇的是， 在被调用时， 回调函数会记住它自身声明时所在的上下文， 并且可以访问该上下文及其父上下文里的所有变量， 这个强大的特性是 Node 成功的核心。

下面的例子展示了在Web浏览器中进行 JavaScript 编程时，闭包是如何工作的。例如，如果想监听按钮的单击事件， 可以按如下方式：

```js
var clickCount = 0;
document.getElementByld('myButton').onclick = function () {
    clickCount += l;
    alert("clicked " + clickCount +"times.");
};
```

或者应用 jQuery

```js
// 自执行匿名函数
(function () {
    var clickCount = 0;
    $('#myButton').onclick = function () {
        clickCount ++;
        alert("clicked " + clickCount +"times.");
    };
}());
```

在 JavaScript 中， 函数是第一类对象，这意味着可以将函数作为参数传递给其他函数。在上述两个例子中， 你把一个函数赋值给另一个函数， 或者将函数作为参数传递给另一个函数以备稍后执行。单击处理程序——也就是你的回调函数——可以访问函数声明作用下的每一个变量， 在本例中也就是说回调函数可以访问父闭包中声明的 `clickCount` 变量。

变量 `clickCount` 存储了用户单击按钮的次数， 该变量在全局域中存储（你在 JavaScript 中可到达的最外层作用域）。在全局域存储变量是一种不好的做法，因为很容易和其他代码发生冲突， 你应该将变量放在需要调用函数的局部作用域中， 大多数时候将代码包装在函数中以额外创建闭包就可以避免污染全局作用域， 如下例所示：

```js
// 自执行匿名函数
(function () {
    var clickCount = 0;
    $('#myButton').onclick = function () {
        clickCount ++;
        alert("clicked " + clickCount +"times.");
    };
}());
```

> **\[info\]** 注意：
>
> 上面的代码定义了一个函数之后立即对其进行了调用，这是一种常见的 JavaScript 模式：** 通过创建函数来创建新的作用域**。



