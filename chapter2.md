# Node 简介

**本章提要：**

* 什么是事件驱动编程风格？使用这种风格有什么优点？

* Node.js 和 JavaScript 如何简化了事件驱动编程？

<p class="indent">在传统编程中，I/O 操作和本地函数调用的处理方式相同： 处理过程需要一直等待直到某个操作结束才能继续下去。这种进行 I/O 操作的阻塞式编程模型继承自早期的分时系统，在这类系统中，每一个进程都对应着一个用户，这样做的目的是使用户之间相互隔离。并且在这类系统中， 用户在决定下一步操作之前， 通常都必须先结束一个操作。但是随着计算机网络和 Internet 的广泛应用，这种“ 单用户、单进程” 的模型不具备较好的伸缩性，管理众多进程在内存和上下文交换代价方面给操作系统带来了沉重的负担， 当任务的数量达到一定值后， 其性能就开始急剧下降。</p>

在除了上述编程模型之外，多线程编程模型是另一个选择。线程可以看做是一种轻量级进程，它与同一进程内的其他线程共享内存。线程作为早期模型的扩展而被创建， 以适应若干并发线程的执行。当一个线程等待 I/O 操作时， 另一个线程就可以接管CPU, 等待线程将在 I/O 操作结束时被唤醒， 这意味着线程在其执行期间可以被中断，之后又能够恢复执行，并且有些系统允许线程在不同的CPU核上并行运行。

在这意味着程序员并不知道在给定时刻究竟是哪些线程在执行，所以他们必须仔细处理对共享内存状态的并发访问， 使用诸如线程锁和信号量这样的同步原语协调对某些数据结构的访问， 强制它们对线程执行调度的各种途径进行预测以避免问题的发生。假如应用程序非常依赖于线程间的共享状态， 那么这种编程方式容易导致随机发生的危险错误， 并且这些错误很难查找。

如果不让操作系统进行线程调度， 那么程序员的另一个选择是协同多线程， 在这种模式下，程序员负责显式地让 CPU 为其他线程的执行分配时间，因为是人为负责线程调度，所以可以放宽同步需求，但是基于和普通多线程同样的原因，这种方法也很复杂并且容易出错。

