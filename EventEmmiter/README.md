# 使用事件发射器模式简化事件绑定

**本章提要：**

* 事件发射器模式简介

* 绑定和解绑定事件监听器

* 创建自定义的事件发射器

在 Node 中，很多对象都能够发射事件，例如，每当有新客户端连接时，TCP 服务器就会发射 "connect" 事件，又比如每读取一整块数据，文件流就会发射 ''data" 事件， 这些对象在 Node 中被称为事件发射器， 它可以让程序员订阅感兴趣的事件，并将回调函数绑定到相关的事件上，每当事件发射器发射事件时， 对应的回调函数就会被调用。 这种发布/订阅模式非常类似于传统的图形用户界面\(Graphic User Interface, GUI\)模式， 比如按钮被单击时， 应用程序就会得到通知。 通过这种模式， 服务器端的程序就会对某些事件的发生做出响应， 比如有客户端连接、 套接字上有可用数据或者是文件关闭。

还可以创建自定义的事件发射器，实际上 Node 提供了一个伪类 EventEmitter，可以将其作为基类来创建自定义的事件发射器。

## 理解标准回调模式

异步编程并不使用函数返回值表示函数调用的结束，而是采用后继传递 \(continuation-passing style, CPS\)取而代之。

> 后继传递风格是一种程序的流程控制权以后继的形式被显式传递的编程风格。\(...\)
>
> 按后继传递风格编写的函数以一个显式的”后继” 作为额外参数，”后继” 实际是一个函数，当CPS函数计算出返回值时，它就会调用后继函数，并将CPS函数的返回值作为其参数。

在后继传递风格中，每个函数在执行完毕后都会调用一个回调函数， 以使程序能够继续运行下去。正如将看到的那样，JavaScript 很适合这种编程风格， 下面是一个在 Node 将文件加载到内存的例子：

```js
var fs = require("fs");
fs.readFile('/etc/passwd', function (err, fileContent) {

if {err) {
        throw err;
    }
    console.log('file content', fileContent.toString());
});
```

在这个例子中， 将一个内联匿名函数传递给 `fs.readFile` 函数作为其第二个参数，其实这就是在使用 CPS，因为在这个内联匿名函数内将函数执行继续了下去。

如你所见，回调函数的第一个参数是一个错误对象，如果有错误发生，这个参数将会是 Error 类的一个实例，这是 Node 中应用 CPS 编程的一般模式。当没有错误发生时，这个参数为 `NULL`。

## 理解事件发射器模式

在标准回调模式中，将一个回调函数作为参数传递给将被执行的函数，这种模式在函数执行结束后需要通知客户端的情况下工作得很好。但是如果在函数执行过程中发生了多个事件或者事件反复发生了多次，那这种模式就工作得不是那么好了。例如，如果有兴趣在套接字（socket）上每当有可用数据时都能够得到通知，标准回调模式就帮不上什么忙了， 此时正是事件发射器模式派上用场的时候，并且可以用标准的接口清楚地区分事件发射器和事件监听器。

在使用事件发生器模式时，会涉及两个或更多的对象，这些对象包括一个或者多个事件监听器。

顾名思义， 事件发射器就是可以发射事件的对象，而事件监听器则是绑定到事件发射器上的代码，负责监听特定类型的事件， 如下面的例子所示：

